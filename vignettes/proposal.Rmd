---
title: "Joint profiling of native and R code"
author: "Kirill MÃ¼ller"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Vignette Title}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

# The Problem

## What problem do you want to solve?

The [three rules of software optimization](http://www.moscowcoffeereview.com/programming/the-3-rules-of-optimization/) are:

1. Don't.
2. Don't do it yet.
3. Profile before optimizing.

This proposal aims at simplifying the application of these rules for R code that calls into native code.

## Why is it a problem?

R has excellent facilities for profiling R code: the main entry point is the [`Rprof()`](https://www.rdocumentation.org/packages/utils/versions/3.3.2/topics/Rprof) function that starts an execution mode that periodically samples the R call stack (optionally at source line level) and writes it to a file.
Optionally, memory usage can also be collected.
The results of a profiling run can be analyzed with `summaryRprof()`, or visualized using the `profvis`, `aprof`, or `GUIProfiler` packages.

With `Rprof()`, the execution time of native code is only available as a bulk, without detailed source information.
Conversely, when using a native code profiler such as [`gperftools`](https://gperftools.github.io/gperftools/cpuprofile.html) or [`callgrind`](http://valgrind.org/docs/manual/cl-manual.html), the resulting profile does not contain any link to the original R source code.
The same applies to memory usage information.

This project aims at bridging this gap with a drop-in replacement to `Rprof()` that records call stacks and memory usage information at both R and native levels, and later commingles them to present a unified view to the user.


## Who does it affect?

Calling native code from R is done mostly for one or both of the following reasons:

1. A particular algorithm or library is implemented in C/C++/Fortran/..., the R code is mostly a wrapper around the native code. Examples:
    - `randomForest` has C and Fortran code at its core
    - `curl` wraps libcurl
    - `RSQLite` wraps SQLite
2. An implementation of a particular functionality in R is too slow for its application and is substituted by a faster native variant. Examples:
    - Converting a matrix to a data frame in `tibble`
    - Fast computation of groupwise aggregates in `dplyr` and `data.table`
    - Graph algorithms in `igraph`
    - ...

Calls to native code from R packages are widespread:
More than 500 CRAN packages consist mostly of C code, according to a [GitHub search](https://github.com/search?q=org%3Acran+language%3Ac&ref=searchresults&type=Repositories&utf8=%E2%9C%93).
The [`Rcpp` package](https://cran.r-project.org/package=Rcpp), which makes it trivial to embed C++ code into a package, is currently used by over 900 CRAN packages.
Furthermore, it is very easy to create a one-off C++ function for use in an analysis script with the help of `Rcpp::cppFunction()`.

## What will solving the problem enable?

Improved profiling facilities will greatly simplify the analysis and elimination of run time and memory bottlenecks in such code.[^rsqlite-slow] Over time, faster and less memory-hungry implementations will save computational resources or allow tackling larger problems.

[^rsqlite-slow]:
For example, a performance regression in a development version of `RSQLite` turned out to be due to unexpectedly slow processing of R code, and not by a problem in the native code.
The R profiling results seemed inconclusive, because the extra run time was being spent during the evaluation of a promise.
The C++ profiling results have indicated that time was spent evaluating R code, but of course not which particular R  code.
With unified profiling data, the problem would have been spotted much easier.


# The Plan

## How are you going to solve the problem?

## Hints

Include the concrete actions you will take and an estimated timeline. What are likely failure modes and how will you recover from them?

# How Can The ISC Help

## Please describe how you think the ISC can help.

## Hints

If you are looking for a cash grant include a detailed itemised budget and spending plan. We expect that most of the budget will be allocated for people, but we will consider funding travel, equipment and services, such as cloud computing resources with good justification. Also describe how you think the ISC can we help promote your project.

# Dissemination

## How will you ensure that your work is available to the widest number of people?

## Hints

Please specify the open source license will you use, how you will host your code so that others can contribute, and how you will publicise your work. We encourage you to plan at least two blog posts to the R consortium blog: one to announce the project, and one to write up what you achieved.
