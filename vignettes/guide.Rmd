---
title: "Introduction to joint profiling of native and R code"
author: "Kirill Müller"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Kirill Müller}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
knitr::opts_chunk$set(cache = TRUE)

options(width = 95)
```

For this vignette, we'll be profiling R and C++ implementations of functions that computes the Fibonacci sequence using [dynamic programming](https://en.wikipedia.org/wiki/Dynamic_programming#In_computer_programming):

```{r fib-r}
fib_r <- function(x) {
  if (x <= 2) return(rep(1, x))
  fib <- fib_r(x - 1)
  c(fib, fib[x - 1] + fib[x - 2])
}
```

```{Rcpp}
#include <Rcpp.h>

// [[Rcpp::export]]
Rcpp::NumericVector fib_cpp(int x) {
  if (x <= 1) return Rcpp::NumericVector::create(1);
  if (x <= 2) return Rcpp::NumericVector::create(1, 1);
  Rcpp::NumericVector fib = fib_cpp(x - 1);

  // Zero-based indexing!
  fib.push_back(fib[x - 1 - 1] + fib[x - 2 - 1]);

  return fib;
}
```

(A few tweaks are necessary to allow profiling the *Rcpp*-compiled function when run from the vignette. See the source for details.)

```{r patch-fib-r, include = FALSE}
code <- as.list(body(fib_cpp))
# gprofiler is looking for calls to .Call, but Rcpp creates .Primitive(".Call")
# Replacing.
code[[1]] <- quote(.Call)
# Get rid of compiled state
fib_cpp <- function(x) NULL
body(fib_cpp) <- call("{", as.call(code))
# Still necessary
compiler::enableJIT(0)
```

The implementations are supposed to behave identically.

```{r eval-fib}
fib_r(10)
fib_cpp(10)
```

Our test function `test()` calls both functions and compares their output in a loop:

```{r test-fun}
test <- function(i) {
  for (i in seq_len(i)) {
    stopifnot(identical(fib_r(i), fib_cpp(i)))
  }
}
```


## A minimal example

R contains a built-in sampling profiler, accessible via [`Rprof()`](https://www.rdocumentation.org/packages/utils/versions/3.4.3/topics/Rprof).
It works by halting execution of the program every so often (by default 50 times per second) and then recording the [call stack](https://www.rdocumentation.org/packages/base/versions/3.4.3/topics/sys.parent).
The combined samples will likely show in which part of your code the most time is spent.
Results can be aggregated with [`summaryRprof()`](https://www.rdocumentation.org/packages/utils/versions/3.4.3/topics/summaryRprof):

```{r minimal-plain-rprof}
out_file <- tempfile("gprofiler", fileext = ".out")
Rprof(out_file, gc.profiling = TRUE)
for (i in 1:10) test(800)
Rprof(NULL)

summary <- summaryRprof(out_file)
summary$by.self
```

This is a nice overview, but for `fun_cpp()` the run time is hidden in the entry for [`.Call()`](https://www.rdocumentation.org/packages/base/versions/3.4.3/topics/CallExternal): calls into native code are opaque and cannot be resolved further. Enter joint profiling:

```{r minimal-gprofiler}
library(gprofiler)
out_file <- tempfile("gprofiler", fileext = ".out")
start_profiler(out_file)
for (i in 1:10) test(700)
stop_profiler()

summary <- summaryRprof(out_file)
summary$by.self
```

The summary now also contains a breakdown for native functions below the R code that calls them.


## Installation

The *gprofiler* package currently requires Linux, it has been tested on Ubuntu only. Various system dependencies are required:

- *gprofiler* requires [perftools](https://github.com/gperftools/gperftools)
- the necessary *profiler* package requires ProtoBuf development files
- the (for now necessary) *pprof* package requires Go
- drawing call graphs in `pprof` requires GraphViz

On Ubuntu, all of these can be installed via `apt`:

```sh
sudo apt install \
  libgoogle-perftools-dev \
  libprotoc-dev libprotobuf-dev protobuf-compiler \
  golang-go \
  graphviz
```

Installing the R package from GitHub will also install the two dependencies, *pprof* and *profile*:

```r
# install.packages("remotes")
remotes::install_github("r-prof/gprofiler")
```

## Usage

The [`start_profiler()` and `stop_profiler()`](https://r-prof.github.io/gprofiler/reference/start_profiler.html) functions are replacements for `Rprof()` and `Rprof(NULL)`, respectively. The generated output file is compatible with that generated by `Rprof()`. This enables a variety of ways to analyze the results, see also the subsequent section.

```{r show-out-contents}
out_file <- tempfile("gprofiler", fileext = ".out")
start_profiler(out_file)
for (i in 1:10) test(700)
stop_profiler()

strtrim(readLines(out_file, n = 12), 90)
```

Furthermore `stop_profiler()` returns an in-memory representation of the profiled data, invisibly. See [`?profiler::validate_profile`](https://r-prof.github.io/profile/reference/validate_profile.html) for a description of the data format.

```{r show-profile-data}
out_file <- tempfile("gprofiler", fileext = ".out")
start_profiler(out_file)
for (i in 1:10) test(700)
profile_data <- stop_profiler()

profile_data

profile_data$samples
profile_data$locations
profile_data$functions
```

The profile data can be edited, and written to a file via [`write_rprof()`](https://r-prof.github.io/profile/reference/write_rprof.html) or (in [`pprof`](https://github.com/google/pprof)-compatible format) via [`profile::write_pprof()`](https://r-prof.github.io/profile/reference/write_pprof.html). The example below removes the first 15 entries from all samples, and writes the resulting profile data in `pprof` format:

```{r tweak-profile-data}
profile_data$samples$locations <- lapply(
  profile_data$samples$locations,
  head,
  -15
)

pprof_file <- tempfile("gprofiler", fileext = ".pb.gz")
profile::write_pprof(profile_data, pprof_file)
```

We then use `pprof` to visualize the call *graph*. The only exported function in the *pprof* package, [`get_pprof_pkg_path()`](https://r-prof.github.io/r-pprof/reference/get_pprof_pkg_path.html), tells us the path to the `pprof` executable.

```{r minimal-graph}
svg_file <- here::here("vignettes/guide_fig/minimal.svg")

system2(
  pprof::get_pprof_pkg_path(),
  c(
    "-svg",
    "-nodefraction 0.01",
    "-output",
    shQuote(svg_file),
    shQuote(pprof_file)
  )
)
```

![Call graph](guide_fig/minimal.svg)

The call graph shows a unified view of run time costs for both R and native code.

For interactive exploration of a call graph, try the built-in web browser view:

```r
system2(
  pprof::get_pprof_pkg_path(),
  c(
    "-http",
    "localhost:8080",
    shQuote(pprof_file)
  )
)
```

You can also create a symlink to the pprof executable in a directory on your path, and run the command from the shell:

```r
file.symlink(pprof::get_pprof_pkg_path(), "~/bin")
```

```sh
pprof -http localhost:8080 gprofiler.pb.gz
```

## Other packages for analyzing profiler data

I'm aware of the following R packages that process profiler data, ordered by date of first CRAN release:

- [*proftools*](https://cran.r-project.org/web/packages/proftools/index.html): Mature, the paper's includes facilities for summarizing results at the function, call,
and source line level; for filtering to narrow the focus to functions of primary interest;
and for visualizing profiling data. Also offers an export to [callgrind](http://valgrind.org/docs/manual/cl-manual.html) format.

- [*profvis*](https://rstudio.github.io/profvis/): Interactive exploration of the flame graph and call tree in a web browser.

- [*prof.tree*](https://github.com/artemklevtsov/prof.tree#proftree): Shows a call tree on the console.

I'd also like to mention two other tools outside the R ecosystem:

- [`pprof`](https://github.com/google/pprof): A new tool written in Go, supports varios output formats (including callgrind) and also interactive exploration of the flame graph and call graph in a web browser.

- [KCacheGrind](https://kcachegrind.github.io/html/Home.html): KDE-based interactive exploration, expects callgrind input.


## Caveats

A few major points have been left unresolved until a forthcoming release:

- Nested calls back into R code are not fully supported yet. In situations where native code evaluates R expressions which then invoke native code again, the recorded stack trace will look wrong.

- OS X is not supported yet: the recording of native call stacks for the R binary doesn't work as expected. These problems seem fixable, in contrast to Windows support which will require a different approach for capturing native stack traces.

- Very deep recursions (like in this vignette) may lead to profiler output which the *profile* package fails to parse.

If your R code calls into native code, or if you want to try `pprof` with R profiling results, give the *gprofiler* package a try! If you discover problems or have comments, [file an issue](https://github.com/r-prof/gprofiler/issues). I'd be especially grateful for help with other Linux distributions or OS X.
