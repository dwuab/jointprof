---
title: "Introduction to joint profiling of native and R code"
author: "Kirill Müller"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Kirill Müller}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
knitr::opts_chunk$set(cache = TRUE)

options(width = 95)
```

For this vignette, we'll be profiling R and C++ implementations of functions that computes the Fibonacci sequence using [dynamic programming](https://en.wikipedia.org/wiki/Dynamic_programming#In_computer_programming):

```{r fib-r}
fib_r <- function(x) {
  if (x <= 2) return(rep(1, x))
  fib <- fib_r(x - 1)
  c(fib, fib[x - 1] + fib[x - 2])
}
```

```{Rcpp}
#include <Rcpp.h>

// [[Rcpp::export]]
Rcpp::NumericVector fib_cpp(int x) {
  if (x <= 1) return Rcpp::NumericVector::create(1);
  if (x <= 2) return Rcpp::NumericVector::create(1, 1);
  Rcpp::NumericVector fib = fib_cpp(x - 1);

  // Zero-based indexing!
  fib.push_back(fib[x - 1 - 1] + fib[x - 2 - 1]);

  return fib;
}
```

(A few tweaks are necessary to allow profiling the *Rcpp*-compiled function when run from the vignette. See the source for details.)

```{r patch-fib-r, include = FALSE}
code <- as.list(body(fib_cpp))
# gprofiler is looking for calls to .Call, but Rcpp creates .Primitive(".Call")
# Replacing.
code[[1]] <- quote(.Call)
# Get rid of compiled state
fib_cpp <- function(x) NULL
body(fib_cpp) <- call("{", as.call(code))
# Still necessary
compiler::enableJIT(0)
```

The implementations are supposed to behave identically.

```{r eval-fib}
fib_r(10)
fib_cpp(10)
```

Our test function `test()` calls both functions and compares their output in a loop:

```{r test-fun}
test <- function(i) {
  for (i in seq_len(i)) {
    stopifnot(identical(fib_r(i), fib_cpp(i)))
  }
}
```


## A minimal example

R contains a built-in sampling profiler, accessible via [`Rprof()`](https://www.rdocumentation.org/packages/utils/versions/3.4.3/topics/Rprof).
It works by halting execution of the program every so often (by default 50 times per second) and then recording the [call stack](https://www.rdocumentation.org/packages/base/versions/3.4.3/topics/sys.parent).
Results can be aggregated with [`summaryRprof()`](https://www.rdocumentation.org/packages/utils/versions/3.4.3/topics/summaryRprof):

```{r minimal-plain-rprof}
out_file <- tempfile("gprofiler", fileext = ".out")
Rprof(out_file, gc.profiling = TRUE)
for (i in 1:10) test(800)
Rprof(NULL)

summary <- summaryRprof(out_file)
summary$by.self
```

This is a nice overview, but for `fun_cpp()` the run time is hidden in the entry for [`.Call()`](https://www.rdocumentation.org/packages/base/versions/3.4.3/topics/CallExternal): calls into native code are opaque and cannot be resolved further. Enter joint profiling:

```{r minimal-gprofiler}
library(gprofiler)
out_file <- tempfile("gprofiler", fileext = ".out")
start_profiler(out_file)
for (i in 1:10) test(800)
stop_profiler()

summary <- summaryRprof(out_file)
summary$by.self
```

We use Google's `pprof` to visualize the call *graph*, after removing a chain of 15 calls common to all samples:

```{r minimal-graph}
profile_data <- profile::read_rprof(out_file)

profile_data$samples$locations <- lapply(
  profile_data$samples$locations,
  head,
  -15
)

pprof_file <- tempfile("gprofiler", fileext = ".pb.gz")
profile::write_pprof(profile_data, pprof_file)

svg_file <- here::here("vignettes/guide_fig/minimal.svg")

system2(
  pprof::get_pprof_path(),
  c(
    "-svg",
    "-nodefraction 0.01",
    "-output",
    shQuote(svg_file),
    shQuote(pprof_file)
  ),
  wait = TRUE
)
```

![Call graph](guide_fig/minimal.svg)

The call graph shows a unified view of run time costs for both R and native code.

- Installation

- Usage

- Other packages
    - profvis
    - proftools
    - prof.tree
    - 
